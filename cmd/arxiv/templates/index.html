{{define "index"}}
{{template "head" .}}
<h1>arXiv.gg</h1>
<form class="search-form" action="/search" method="get" id="search-form">
	<input type="text" name="q" id="search-input" placeholder="Search or paste arXiv ID/URL..." value="{{.Query}}" autocomplete="off">
	<button type="submit">Search</button>
</form>
<div class="search-mode-toggle">
	<label class="toggle-label">
		<input type="radio" name="search-mode" value="keyword" checked id="mode-keyword">
		<span class="toggle-text">Keyword</span>
	</label>
	<label class="toggle-label">
		<input type="radio" name="search-mode" value="semantic" id="mode-semantic">
		<span class="toggle-text">Semantic</span>
	</label>
</div>
<div id="search-results" class="search-results"></div>
<p>{{.Stats.TotalPapers}} papers cached ({{.Stats.SourcesDownloaded}} with source, {{.Stats.PDFsDownloaded}} with PDF)</p>
<div id="embedding-progress" style="display: none; margin: 20px 0; padding: 15px; background: #f0f8ff; border-radius: 5px; border-left: 4px solid #007bff;">
	<h3 style="margin: 0 0 10px 0;">Generating Embeddings</h3>
	<div id="embedding-status">Starting...</div>
	<div id="embedding-bar-container" style="width: 100%; height: 20px; background: #e9ecef; border-radius: 10px; overflow: hidden; margin: 10px 0;">
		<div id="embedding-bar" style="height: 100%; background: #007bff; width: 0%; transition: width 0.3s ease;"></div>
	</div>
	<div id="embedding-message"></div>
</div>
<button id="generate-embeddings-btn" style="margin: 10px 0; padding: 8px 16px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer;">Generate Embeddings</button>
<div id="recent-papers">
<h2>Recent Papers</h2>
{{range .Papers}}
<div class="paper">
	<span class="paper-id">{{.ID}}</span>
	{{if .SourceDownloaded}}<span class="badge badge-src">src</span>{{end}}
	{{if .PDFDownloaded}}<span class="badge badge-pdf">pdf</span>{{end}}
	<div class="paper-title"><a href="/paper/{{.ID}}">{{.Title}}</a></div>
	<div class="paper-authors">{{.Authors}}</div>
	<div class="paper-categories">{{range $i, $c := parseCategories .Categories}}{{if $i}} {{end}}<a class="cat-link" href="/category/{{$c}}">{{$c}}</a>{{end}}</div>
</div>
{{else}}
<p>No papers cached yet. Use <code>arxiv fetch</code> or <code>arxiv sync</code> to add papers.</p>
{{end}}
</div>
<script>
(function() {
	const input = document.getElementById('search-input');
	const results = document.getElementById('search-results');
	const recent = document.getElementById('recent-papers');
	let timeout = null;

	function renderPaper(p, similarity = null) {
		// Handle both API formats: lowercase (keyword search) and capitalized (semantic search)
		const id = p.id || p.ID;
		const title = p.title || p.Title || '';
		const authors = p.authors || p.Authors || '';
		const categories = p.categories || p.Categories || '';
		const hasSource = p.src || p.SourceDownloaded;
		const hasPdf = p.pdf || p.PDFDownloaded;
		
		const cats = categories.split(' ').filter(c => c).map(c =>
			'<a class="cat-link" href="/category/' + c + '">' + c + '</a>'
		).join(' ');
		const badges = (hasSource ? '<span class="badge badge-src">src</span>' : '') +
		               (hasPdf ? '<span class="badge badge-pdf">pdf</span>' : '');
		const similarityBadge = similarity !== null ? '<span class="badge badge-similarity">' + Math.round(similarity * 100) + '% match</span>' : '';
		return '<div class="paper">' +
			'<span class="paper-id">' + id + '</span> ' + badges + ' ' + similarityBadge +
			'<div class="paper-title"><a href="/paper/' + id + '">' + escapeHtml(title) + '</a></div>' +
			'<div class="paper-authors">' + escapeHtml(authors) + '</div>' +
			'<div class="paper-categories">' + cats + '</div>' +
		'</div>';
	}

	function escapeHtml(s) {
		const div = document.createElement('div');
		div.textContent = s;
		return div.innerHTML;
	}

	// Check if input looks like an arXiv ID or URL
	function extractArxivID(input) {
		input = input.trim();
		// New format: YYMM.NNNNN or YYMM.NNNNNN
		const newFormat = /^(\d{4}\.\d{4,6})$/;
		if (newFormat.test(input)) return input;
		// Old format: category/NNNNNNN
		const oldFormat = /^([a-z-]+\/\d{7,})$/i;
		if (oldFormat.test(input)) return input;
		// URL patterns
		const urlPattern = /arxiv\.org\/(?:abs|pdf)\/(\d{4}\.\d{4,6}|[a-z-]+\/\d{7,})/i;
		const match = input.match(urlPattern);
		if (match) {
			let id = match[1];
			// Remove version suffix
			id = id.replace(/v\d+$/, '');
			return id;
		}
		return null;
	}

	function doSearch(query) {
		if (!query.trim()) {
			results.innerHTML = '';
			recent.style.display = '';
			return;
		}

		// Check if it's an arXiv ID - redirect immediately
		const arxivID = extractArxivID(query);
		if (arxivID) {
			results.innerHTML = '<p class="search-status">Loading paper ' + escapeHtml(arxivID) + '...</p>';
			recent.style.display = 'none';
			window.location.href = '/paper/' + arxivID;
			return;
		}

		const searchMode = document.querySelector('input[name="search-mode"]:checked').value;
		const isSemantic = searchMode === 'semantic';
		
		results.innerHTML = '<p class="search-status">' + (isSemantic ? 'Semantic searching...' : 'Searching...') + '</p>';
		recent.style.display = 'none';

		const endpoint = isSemantic ? '/api/v1/search/semantic' : '/search';
		const params = new URLSearchParams({ q: query });
		if (isSemantic) {
			params.append('limit', '20');
		} else {
			params.append('format', 'json');
		}

		fetch(endpoint + '?' + params.toString())
			.then(r => r.json())
			.then(data => {
				if (!data.success && !data.length) {
					const errorMsg = data.error || 'No results for "' + escapeHtml(query) + '"';
					results.innerHTML = '<p class="search-status">' + errorMsg + '</p>';
					return;
				}

				let papers, count;
				if (isSemantic && data.success) {
					// Semantic search response format
					papers = data.data.results;
					count = data.data.count;
				} else {
					// Keyword search response format (direct array)
					papers = data;
					count = data.length;
				}

				if (!papers || papers.length === 0) {
					results.innerHTML = '<p class="search-status">No results for "' + escapeHtml(query) + '"</p>';
					return;
				}

				const searchTypeLabel = isSemantic ? 'semantic' : 'keyword';
				results.innerHTML = '<p class="search-status">' + count + ' ' + searchTypeLabel + ' results for "' + escapeHtml(query) + '"</p>' +
					papers.map(p => {
						// Handle different paper object structures
						const paper = p.paper || p;
						const similarity = isSemantic ? p.similarity : null;
						return renderPaper(paper, similarity);
					}).join('');
			})
			.catch(err => {
				const errorType = isSemantic ? 'Semantic search unavailable' : 'Search error';
				results.innerHTML = '<p class="search-status">' + errorType + '</p>';
			});
	}

	input.addEventListener('input', function() {
		clearTimeout(timeout);
		timeout = setTimeout(() => doSearch(input.value), 300);
	});

	// Also handle form submit for immediate redirect on arXiv IDs or semantic search
	document.getElementById('search-form').addEventListener('submit', function(e) {
		const arxivID = extractArxivID(input.value);
		if (arxivID) {
			e.preventDefault();
			window.location.href = '/paper/' + arxivID;
			return;
		}
		
		const searchMode = document.querySelector('input[name="search-mode"]:checked').value;
		if (searchMode === 'semantic') {
			e.preventDefault();
			doSearch(input.value);
		}
	});

	// Embedding generation functionality
	const generateBtn = document.getElementById('generate-embeddings-btn');
	const progressDiv = document.getElementById('embedding-progress');
	const statusDiv = document.getElementById('embedding-status');
	const messageDiv = document.getElementById('embedding-message');
	const progressBar = document.getElementById('embedding-bar');

	generateBtn.addEventListener('click', function() {
		const limit = prompt('Enter limit (number of papers to process, leave empty for all):');
		
		generateBtn.style.display = 'none';
		progressDiv.style.display = 'block';
		statusDiv.textContent = 'Starting embedding generation...';
		messageDiv.textContent = '';
		progressBar.style.width = '0%';

		const url = '/api/v1/generate/embeddings';
		const params = limit ? '?limit=' + encodeURIComponent(limit) : '';
		
		fetch(url + params, {
			method: 'POST',
			headers: {
				'Accept': 'text/event-stream',
				'Cache-Control': 'no-cache'
			}
		})
		.then(response => {
			if (!response.ok) {
				throw new Error('HTTP ' + response.status);
			}
			return response.body.getReader();
		})
		.then(reader => {
			const decoder = new TextDecoder();
			
			function readStream() {
				return reader.read().then(({done, value}) => {
					if (done) {
						statusDiv.textContent = 'Completed';
						progressBar.style.width = '100%';
						generateBtn.style.display = 'block';
						return;
					}
					
					const chunk = decoder.decode(value, {stream: true});
					const lines = chunk.split('\n');
					
					for (const line of lines) {
						if (line.startsWith('data: ')) {
							try {
								const data = JSON.parse(line.substring(6));
								handleEmbeddingEvent(data);
							} catch (e) {
								// Ignore malformed JSON
							}
						}
					}
					
					return readStream();
				});
			}
			
			return readStream();
		})
		.catch(err => {
			statusDiv.textContent = 'Error: ' + err.message;
			progressDiv.style.display = 'none';
			generateBtn.style.display = 'block';
		});
	});

	function handleEmbeddingEvent(data) {
		switch (data.type) {
			case 'start':
				statusDiv.textContent = data.message || 'Starting...';
				break;
			case 'progress':
				if (data.current !== undefined && data.total !== undefined) {
					const percent = data.total > 0 ? (data.current / data.total * 100) : 0;
					progressBar.style.width = percent + '%';
					statusDiv.textContent = `Processed ${data.current}/${data.total} papers (${Math.round(percent)}%)`;
				}
				if (data.message) {
					messageDiv.textContent = data.message;
				}
				break;
			case 'status':
				if (data.message) {
					messageDiv.textContent = data.message;
				}
				break;
			case 'complete':
				statusDiv.textContent = data.message || 'Completed';
				progressBar.style.width = '100%';
				if (data.count !== undefined) {
					messageDiv.textContent = `Total embeddings: ${data.count}`;
				}
				setTimeout(() => {
					progressDiv.style.display = 'none';
					generateBtn.style.display = 'block';
				}, 3000);
				break;
			case 'error':
				statusDiv.textContent = 'Error occurred';
				messageDiv.textContent = data.error || 'Unknown error';
				setTimeout(() => {
					progressDiv.style.display = 'none';
					generateBtn.style.display = 'block';
				}, 5000);
				break;
			case 'close':
				setTimeout(() => {
					progressDiv.style.display = 'none';
					generateBtn.style.display = 'block';
				}, 1000);
				break;
		}
	}
 })();
 </script>
{{template "foot" .}}
{{end}}
