{{define "index"}}
{{template "head" .}}
<h1>arXiv.gg</h1>
<form class="search-form" action="/search" method="get" id="search-form">
	<input type="text" name="q" id="search-input" placeholder="Search or paste arXiv ID/URL..." value="{{.Query}}" autocomplete="off">
	<button type="submit">Search</button>
</form>
<div class="search-mode-toggle">
	<label class="toggle-label">
		<input type="radio" name="search-mode" value="keyword" checked id="mode-keyword">
		<span class="toggle-text">Keyword</span>
	</label>
	<label class="toggle-label">
		<input type="radio" name="search-mode" value="semantic" id="mode-semantic">
		<span class="toggle-text">Semantic</span>
	</label>
</div>
<div id="search-results" class="search-results"></div>
<p>{{.Stats.TotalPapers}} papers cached ({{.Stats.SourcesDownloaded}} with source, {{.Stats.PDFsDownloaded}} with PDF)</p>

<div id="recent-papers">
<h2>Recent Papers</h2>
{{range .Papers}}
<div class="paper">
	<span class="paper-id">{{.ID}}</span>
	{{if .SourceDownloaded}}<span class="badge badge-src">src</span>{{end}}
	{{if .PDFDownloaded}}<span class="badge badge-pdf">pdf</span>{{end}}
	<div class="paper-title"><a href="/paper/{{.ID}}">{{.Title}}</a></div>
	<div class="paper-authors">{{.Authors}}</div>
	<div class="paper-categories">{{range $i, $c := parseCategories .Categories}}{{if $i}} {{end}}<a class="cat-link" href="/category/{{$c}}">{{$c}}</a>{{end}}</div>
</div>
{{else}}
<p>No papers cached yet. Use <code>arxiv fetch</code> or <code>arxiv sync</code> to add papers.</p>
{{end}}
</div>
<script>
(function() {
	const input = document.getElementById('search-input');
	const results = document.getElementById('search-results');
	const recent = document.getElementById('recent-papers');
	let timeout = null;

	function renderPaper(p, similarity = null) {
		// Handle both API formats: lowercase (keyword search) and capitalized (semantic search)
		const id = p.id || p.ID;
		const title = p.title || p.Title || '';
		const authors = p.authors || p.Authors || '';
		const categories = p.categories || p.Categories || '';
		const hasSource = p.src || p.SourceDownloaded;
		const hasPdf = p.pdf || p.PDFDownloaded;
		
		const cats = categories.split(' ').filter(c => c).map(c =>
			'<a class="cat-link" href="/category/' + c + '">' + c + '</a>'
		).join(' ');
		const badges = (hasSource ? '<span class="badge badge-src">src</span>' : '') +
		               (hasPdf ? '<span class="badge badge-pdf">pdf</span>' : '');
		const similarityBadge = similarity !== null ? '<span class="badge badge-similarity">' + Math.round(similarity * 100) + '% match</span>' : '';
		return '<div class="paper">' +
			'<span class="paper-id">' + id + '</span> ' + badges + ' ' + similarityBadge +
			'<div class="paper-title"><a href="/paper/' + id + '">' + escapeHtml(title) + '</a></div>' +
			'<div class="paper-authors">' + escapeHtml(authors) + '</div>' +
			'<div class="paper-categories">' + cats + '</div>' +
		'</div>';
	}

	function escapeHtml(s) {
		const div = document.createElement('div');
		div.textContent = s;
		return div.innerHTML;
	}

	// Check if input looks like an arXiv ID or URL
	function extractArxivID(input) {
		input = input.trim();
		// New format: YYMM.NNNNN or YYMM.NNNNNN
		const newFormat = /^(\d{4}\.\d{4,6})$/;
		if (newFormat.test(input)) return input;
		// Old format: category/NNNNNNN
		const oldFormat = /^([a-z-]+\/\d{7,})$/i;
		if (oldFormat.test(input)) return input;
		// URL patterns
		const urlPattern = /arxiv\.org\/(?:abs|pdf)\/(\d{4}\.\d{4,6}|[a-z-]+\/\d{7,})/i;
		const match = input.match(urlPattern);
		if (match) {
			let id = match[1];
			// Remove version suffix
			id = id.replace(/v\d+$/, '');
			return id;
		}
		return null;
	}

	let activeEventSource = null;

	function doSearch(query) {
		if (!query.trim()) {
			results.innerHTML = '';
			recent.style.display = '';
			if (activeEventSource) {
				activeEventSource.close();
				activeEventSource = null;
			}
			return;
		}

		const arxivID = extractArxivID(query);
		if (arxivID) {
			results.innerHTML = '<p class="search-status">Loading paper ' + escapeHtml(arxivID) + '...</p>';
			recent.style.display = 'none';
			window.location.href = '/paper/' + arxivID;
			return;
		}

		if (activeEventSource) {
			activeEventSource.close();
			activeEventSource = null;
		}

		const searchMode = document.querySelector('input[name="search-mode"]:checked').value;
		const isSemantic = searchMode === 'semantic';
		
		results.innerHTML = '<p class="search-status" id="search-status">' + (isSemantic ? 'Semantic searching...' : 'Searching...') + '</p><div id="paper-results"></div>';
		recent.style.display = 'none';

		const params = new URLSearchParams({ q: query, limit: '100' });
		if (isSemantic) params.append('mode', 'semantic');

		activeEventSource = new EventSource('/api/v1/search/stream?' + params.toString());
		const paperContainer = document.getElementById('paper-results');
		const statusEl = document.getElementById('search-status');
		let resultCount = 0;

		activeEventSource.onmessage = function(e) {
			const data = JSON.parse(e.data);
			
			switch (data.type) {
				case 'start':
					statusEl.textContent = isSemantic ? 'Generating embedding...' : 'Searching...';
					break;
				case 'status':
					statusEl.textContent = data.message;
					break;
				case 'result':
					resultCount++;
					const paper = data.paper;
					const similarity = data.similarity || null;
					paperContainer.insertAdjacentHTML('beforeend', renderPaper(paper, similarity));
					statusEl.textContent = resultCount + ' results found...';
					break;
				case 'complete':
					const modeLabel = data.mode === 'semantic' ? 'semantic' : 'keyword';
					statusEl.textContent = data.count + ' ' + modeLabel + ' results for "' + escapeHtml(query) + '"';
					activeEventSource.close();
					activeEventSource = null;
					break;
				case 'error':
					statusEl.textContent = data.error;
					statusEl.style.color = '#dc2626';
					activeEventSource.close();
					activeEventSource = null;
					break;
			}
		};

		activeEventSource.onerror = function() {
			if (resultCount === 0) {
				statusEl.textContent = 'Search failed - please try again';
				statusEl.style.color = '#dc2626';
			}
			if (activeEventSource) {
				activeEventSource.close();
				activeEventSource = null;
			}
		};
	}

	input.addEventListener('input', function() {
		clearTimeout(timeout);
		timeout = setTimeout(() => doSearch(input.value), 300);
	});

	// Also handle form submit for immediate redirect on arXiv IDs or semantic search
	document.getElementById('search-form').addEventListener('submit', function(e) {
		const arxivID = extractArxivID(input.value);
		if (arxivID) {
			e.preventDefault();
			window.location.href = '/paper/' + arxivID;
			return;
		}
		
		const searchMode = document.querySelector('input[name="search-mode"]:checked').value;
		if (searchMode === 'semantic') {
			e.preventDefault();
			doSearch(input.value);
		}
	});

})();
 </script>
{{template "foot" .}}
{{end}}
