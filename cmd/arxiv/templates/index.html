{{define "index"}}
{{template "head" .}}
<style>
	.terminal { 
		background: #ffffff; 
		border: 1px solid #d1d5db; 
		border-radius: 8px; 
		margin: 1rem 0; 
		overflow: hidden;
		max-height: 0;
		opacity: 0;
		transition: max-height 0.3s ease, opacity 0.2s ease;
	}
	.terminal.active { max-height: 200px; opacity: 1; }
	.terminal-header {
		background: #f9fafb;
		padding: 0.5rem 1rem;
		display: flex;
		align-items: center;
		gap: 0.5rem;
		border-bottom: 1px solid #d1d5db;
	}
	.terminal-dot { width: 12px; height: 12px; border-radius: 50%; }
	.terminal-dot.red { background: #ff5f56; }
	.terminal-dot.yellow { background: #ffbd2e; }
	.terminal-dot.green { background: #27c93f; }
	.terminal-title { color: #6b7280; font-size: 0.75rem; font-family: monospace; margin-left: auto; }
	.terminal-body {
		padding: 1rem;
		font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace;
		font-size: 0.85rem;
		line-height: 1.6;
		color: #1f2937;
	}
	.terminal-line { margin: 0.25rem 0; }
	.terminal-line.prompt::before { content: "$ "; color: #059669; }
	.terminal-line.info { color: #2563eb; }
	.terminal-line.success { color: #059669; }
	.terminal-cursor {
		display: inline-block;
		width: 8px;
		height: 1em;
		background: #1f2937;
		animation: blink 1s step-end infinite;
		vertical-align: text-bottom;
	}
	@keyframes blink { 50% { opacity: 0; } }
</style>
<h1>arXiv.gg</h1>
<form class="search-form" action="/search" method="get" id="search-form">
	<input type="text" name="q" id="search-input" placeholder="Search or paste arXiv ID/URL..." value="{{.Query}}" autocomplete="off">
	<button type="submit">Search</button>
</form>
<div class="search-mode-toggle">
	<label class="toggle-label">
		<input type="radio" name="search-mode" value="keyword" checked id="mode-keyword">
		<span class="toggle-text">Keyword</span>
	</label>
	<label class="toggle-label">
		<input type="radio" name="search-mode" value="semantic" id="mode-semantic">
		<span class="toggle-text">Semantic</span>
	</label>
</div>
<div id="search-results" class="search-results"></div>
<p>{{.Stats.TotalPapers}} papers cached ({{.Stats.SourcesDownloaded}} with source, {{.Stats.PDFsDownloaded}} with PDF, {{.Stats.EmbeddingsCount}} with embeddings)</p>

<div id="recent-papers">
<h2>Recent Papers</h2>
{{range .Papers}}
<div class="paper">
	<span class="paper-id">{{.ID}}</span>
	{{if .SourceDownloaded}}<span class="badge badge-src">src</span>{{end}}
	{{if .PDFDownloaded}}<span class="badge badge-pdf">pdf</span>{{end}}
	<div class="paper-title"><a href="/paper/{{.ID}}">{{.Title}}</a></div>
	<div class="paper-authors">{{.Authors}}</div>
	<div class="paper-categories">{{range $i, $c := parseCategories .Categories}}{{if $i}} {{end}}<a class="cat-link" href="/category/{{$c}}">{{$c}}</a>{{end}}</div>
</div>
{{else}}
<p>No papers cached yet. Use <code>arxiv fetch</code> or <code>arxiv sync</code> to add papers.</p>
{{end}}
</div>
<script>
(function() {
	const input = document.getElementById('search-input');
	const results = document.getElementById('search-results');
	const recent = document.getElementById('recent-papers');
	let timeout = null;

	function renderPaper(p, similarity = null) {
		// Handle both API formats: lowercase (keyword search) and capitalized (semantic search)
		const id = p.id || p.ID;
		const title = p.title || p.Title || '';
		const authors = p.authors || p.Authors || '';
		const categories = p.categories || p.Categories || '';
		const hasSource = p.src || p.SourceDownloaded;
		const hasPdf = p.pdf || p.PDFDownloaded;
		
		const cats = categories.split(' ').filter(c => c).map(c =>
			'<a class="cat-link" href="/category/' + c + '">' + c + '</a>'
		).join(' ');
		const badges = (hasSource ? '<span class="badge badge-src">src</span>' : '') +
		               (hasPdf ? '<span class="badge badge-pdf">pdf</span>' : '');
		const similarityBadge = similarity !== null ? '<span class="badge badge-similarity">' + Math.round(similarity * 100) + '% match</span>' : '';
		return '<div class="paper">' +
			'<span class="paper-id">' + id + '</span> ' + badges + ' ' + similarityBadge +
			'<div class="paper-title"><a href="/paper/' + id + '">' + escapeHtml(title) + '</a></div>' +
			'<div class="paper-authors">' + escapeHtml(authors) + '</div>' +
			'<div class="paper-categories">' + cats + '</div>' +
		'</div>';
	}

	function escapeHtml(s) {
		const div = document.createElement('div');
		div.textContent = s;
		return div.innerHTML;
	}

	// Check if input looks like an arXiv ID or URL
	function extractArxivID(input) {
		input = input.trim();
		// New format: YYMM.NNNNN or YYMM.NNNNNN
		const newFormat = /^(\d{4}\.\d{4,6})$/;
		if (newFormat.test(input)) return input;
		// Old format: category/NNNNNNN
		const oldFormat = /^([a-z-]+\/\d{7,})$/i;
		if (oldFormat.test(input)) return input;
		// URL patterns
		const urlPattern = /arxiv\.org\/(?:abs|pdf)\/(\d{4}\.\d{4,6}|[a-z-]+\/\d{7,})/i;
		const match = input.match(urlPattern);
		if (match) {
			let id = match[1];
			// Remove version suffix
			id = id.replace(/v\d+$/, '');
			return id;
		}
		return null;
	}

	let activeEventSource = null;

	function doSearch(query) {
		if (!query.trim()) {
			results.innerHTML = '';
			recent.style.display = '';
			if (activeEventSource) {
				activeEventSource.close();
				activeEventSource = null;
			}
			return;
		}

		const arxivID = extractArxivID(query);
		if (arxivID) {
			results.innerHTML = '<p class="search-status">Loading paper ' + escapeHtml(arxivID) + '...</p>';
			recent.style.display = 'none';
			window.location.href = '/paper/' + arxivID;
			return;
		}

		if (activeEventSource) {
			activeEventSource.close();
			activeEventSource = null;
		}

		const searchMode = document.querySelector('input[name="search-mode"]:checked').value;
		const isSemantic = searchMode === 'semantic';
		
		if (isSemantic) {
			results.innerHTML = `
				<div class="terminal active" id="search-terminal">
					<div class="terminal-header">
						<span class="terminal-dot red"></span>
						<span class="terminal-dot yellow"></span>
						<span class="terminal-dot green"></span>
						<span class="terminal-title">semantic search</span>
					</div>
					<div class="terminal-body">
						<div class="terminal-line prompt">search --semantic "${escapeHtml(query)}"</div>
						<div class="terminal-line info" id="terminal-status">Generating query embedding...<span class="terminal-cursor"></span></div>
					</div>
				</div>
				<p class="search-status" id="search-status" style="display:none;"></p>
				<div id="paper-results"></div>`;
		} else {
			results.innerHTML = '<p class="search-status" id="search-status">Searching...</p><div id="paper-results"></div>';
		}
		recent.style.display = 'none';

		const params = new URLSearchParams({ q: query, limit: '100' });
		if (isSemantic) params.append('mode', 'semantic');

		activeEventSource = new EventSource('/api/v1/search/stream?' + params.toString());
		const paperContainer = document.getElementById('paper-results');
		const statusEl = document.getElementById('search-status');
		const terminalStatus = document.getElementById('terminal-status');
		const terminal = document.getElementById('search-terminal');
		let resultCount = 0;

		activeEventSource.onmessage = function(e) {
			const data = JSON.parse(e.data);
			
			switch (data.type) {
				case 'start':
					if (isSemantic && terminalStatus) {
						terminalStatus.innerHTML = 'Generating query embedding...<span class="terminal-cursor"></span>';
					} else {
						statusEl.textContent = 'Searching...';
					}
					break;
				case 'status':
					if (isSemantic && terminalStatus) {
						terminalStatus.innerHTML = data.message + '<span class="terminal-cursor"></span>';
					} else {
						statusEl.textContent = data.message;
					}
					break;
				case 'result':
					resultCount++;
					if (terminal) terminal.classList.remove('active');
					statusEl.style.display = '';
					const paper = data.paper;
					const similarity = data.similarity || null;
					paperContainer.insertAdjacentHTML('beforeend', renderPaper(paper, similarity));
					statusEl.textContent = resultCount + ' results found...';
					break;
				case 'complete':
					if (terminal) terminal.classList.remove('active');
					statusEl.style.display = '';
					const modeLabel = data.mode === 'semantic' ? 'semantic' : 'keyword';
					statusEl.textContent = data.count + ' ' + modeLabel + ' results for "' + escapeHtml(query) + '"';
					activeEventSource.close();
					activeEventSource = null;
					break;
				case 'error':
					if (terminal) terminal.classList.remove('active');
					statusEl.style.display = '';
					statusEl.textContent = data.error;
					statusEl.style.color = '#dc2626';
					activeEventSource.close();
					activeEventSource = null;
					break;
			}
		};

		activeEventSource.onerror = function() {
			if (resultCount === 0) {
				statusEl.textContent = 'Search failed - please try again';
				statusEl.style.color = '#dc2626';
			}
			if (activeEventSource) {
				activeEventSource.close();
				activeEventSource = null;
			}
		};
	}

	input.addEventListener('input', function() {
		clearTimeout(timeout);
		const searchMode = document.querySelector('input[name="search-mode"]:checked').value;
		if (searchMode === 'keyword') {
			timeout = setTimeout(() => doSearch(input.value), 300);
		}
	});

	document.getElementById('search-form').addEventListener('submit', function(e) {
		e.preventDefault();
		const arxivID = extractArxivID(input.value);
		if (arxivID) {
			window.location.href = '/paper/' + arxivID;
			return;
		}
		doSearch(input.value);
	});

})();
 </script>
{{template "foot" .}}
{{end}}
